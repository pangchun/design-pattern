# 设计模式简介



## 一、了解设计模式



### 1、是什么

设计模式是代码设计经验的总结，是对于重复发生的问题的解决方案。



### 2、由谁提出

由 `四人帮 GOF` 合著的 `《Design Patterns - Elements of Reusable Object-Oriented Software》` 一书中提出。



### 3、有什么用

主要用于复用、重用代码，提高代码的可扩展性和可维护性。



## 二、设计模式3大分类

设计模式分为3大类：

1. 创建型；
2. 结构型；
3. 行为型。

常用的设计模式的有23种。



### 1、创建型模式

> 《设计模式_可复用面向对象软件的基础》中是这样介绍的：
>
> 创建型模式**抽象了实例化过程**。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。**一个类创建型模式**使用**继承**改变被实例化的类，而一个**对象创建型模式**将实例化委托给另一个对象。
>
> 随着系统演化得越来越依赖于对象复合而不是类继承，创建型模式变得更为重要。当这种情况发生时，重心从对一组固定行为的硬编码(hard-coding)转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类。
>
> 在这些模式中有两个不断出现的主旋律。第一，它们都将关于该**系统使用哪些具体的类的信息封装**起来。第二，它们**隐藏了这些类的实例是如何被创建和放在一起**的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予你很大的灵活性。它们允许你用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定)，也可以是动态的（在运行时)。

可以总结出以下几点：

1. 创建型模式抽象了对象的实例化过程，因此不会使用 **new** 来直接实例化对象；
2. 创建型模式又具体分为：类创建型、对象创建型，类创建型与继承相关，对象创建型由其他对象来进行实例化；
3. 创建型模式的两个特点：封装具体的类信息、隐藏对象的创建逻辑；
4. 创建型模式关注于对象如何创建，将对象的创建与使用分离。

**创建型模式的5种实现：**

1. 单例模式：Singleton Pattern
2. 原型模式：Prototype Pattern
3. 建造者模式：Builder Pattern
4. 工厂方法模式：Factory Method
5. 抽象工厂模式：Abstract Factory Pattern



### 2、结构型模式

> 《设计模式_可复用面向对象软件的基础》中是这样介绍的：
>
> 结构型模式涉及到如何**组合类和对象以获得更大的结构**。**结构型类模式**采用**继承机制**来**组合接口或实现**。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。这一模式尤其有助于多个独立开发的类库协同工作。另外一个例子是类形式的Adapter(4.1)模式。一般来说，适配器使得一个接口(adaptee的接口)与其他接口兼容，从而给出了多个不同接口的统一抽象。为此，类适配器对一个adaptee类进行私有继承。这样，适配器就可以用adaptee的接口表示它的接口。
>
> **结构型对象模式**不是对接口和实现进行组合，而是描述了如何**对一些对象进行组合**，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。

可以总结出以下几点：

1. 结构型模式关注的是组合类和对象来获得更大的结构；
2. 结构型模式分为：类结构型、对象结构型；类结构使用继承来组合接口或实现，对象结构组合对象实现新功能。

**结构型模式的7种实现：**

1. 适配器模式：Adapter Pattern
2. 桥接模式：Bridge Pattern
3. 组合模式：Composite Pattern
4. 装饰器模式：Decorator Pattern
5. 外观模式：Facade Pattern
6. 享元模式：Flyweight Pattern
7. 代理模式：Proxy Pattern



### 3、行为型模式

> 《设计模式_可复用面向对象软件的基础》中是这样介绍的：
>
> 行为模式涉及到**算法和对象间职责的分配**。行为模式不仅描述**对象或类的模式**，还描述它们之间的**通信模式**。这些模式刻划了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。
>
> 行为类模式使用**继承机制**在类间分派行为。本章包括两个这样的模式。其中TemplateMethod（5.10)较为简单和常用。模板方法是一个算法的抽象定义，它逐步地定义该算法，每一步调用一个抽象操作或一个原语操作，子类定义抽象操作以具体实现该算法。另一种行为类模式是Interpreter(5.3)。它将一个文法表示为一个类层次，并实现一个解释器作为这些类的实例上的一个操作。
>
> 行为对象模式使用**对象复合而不是继承**。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。这里一个重要的问题是对等的对象如何互相了解对方。对等对象可以保持显式的对对方的引用，但那会增加它们的耦合度。在极端情况下，每一个对象都要了解所有其他的对象。Mediator（5.5)在对等对象间引人一个mediator对象以避免这种情况的出现。mediator:提供了松耦合所需的间接性。

可以总结出以下几点：

1. 行为型模式注重于类和对象的交互，设计算法和职责分配；
2. 使用对象复合而不是继承。

**行为型模式的11种实现：**

1. 责任链模式：Chain of Responsibility Pattern
2. 命令模式：Command Pattern
3. 解释器模式：Interpreter Pattern
4. 迭代器模式：Iterator Pattern
5. 中介模式：Mediator Pattern
6. 备忘录模式：Memento Pattern
7. 观察者模式：Observer Pattern
8. 状态模式：State Pattern
9. 策略模式：Strategy Pattern
10. 模板模式：Template Pattern
11. 访问者模式：Visitor Pattern



## 三、OOP7大原则



### 1、开闭原则

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用**接口和抽象类**，后面的具体设计中我们会提到这点。



### 2、里氏替换原则

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。**里氏代换原则是对开闭原则的补充**。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

也就是说**在程序中，子类可以替换父类**。



### 3、依赖倒转原则

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

换句话说，就是要面向接口编程，不要面向实现编程。（实现公共接口，而不是每个接口都实现）



### 4、接口隔离原则

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

要为各个类建立他们所需要的专用接口。

比方我们真实开发中，每个实体类对应有自己的service，就是满足了接口隔离原则。



### 5、迪米特法则 （最少知道原则）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。



### 6、合成复用原则

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

所谓的合成/聚合是指一个对象里持有另外一个类的对象，通过调用这些对象的方法得到复用已有功能的目的。



### 7、单一职责原则

控制类的粒度大小、将对象解耦、提高其内聚性。（方法的原子性）













